:toc:
:toclevels: 3


Red is a homoiconic language (Red is its own meta-language and own data-format) and an important paradigm it uses is “code is data”. 
A Red program is a sequence of Red values - everything is data before it’s evaluated. This makes one able to *express any task using syntax that best suits it*. The execution of a Red program is done by evaluating each of its constituent values in turn, according to the evaluation rules.

== Words

A special category of values is word. A word! is a symbolic value that can be used like a variable (the `!` at the end denotes a datatype). Red does not have identifiers nor keywords. Words do not store values, they point to values in some context – the global context by default.
Words are formed by one or more characters from the entire Unicode range, including punctuation characters from the ASCII subset: `! & ' * + - . < = > ? _ | ~` 

Here are some valid words:

----
foo
foo+bar
Fahrenheit451 
C°
__ (two underscores)
----

Words can’t start with a digit and can’t contain any control characters, whitespace characters, and punctuation characters from the ASCII subset: `/ \ ^ , [ ] ( ) { } " # $ % @ : ;`

The presence of `! & ' * + - . < = > ? _ | ~`` in words leads to the implication that they must be delimited by spaces, tabs or \[]\(){}. In Python you can write:
----
a+b
1and a>b
----
In Red you always need to put spaces between words:
----
a + b
1 and a > b
----

Please note that Red is case insensitive.

== Evaluation order

At a semantic level, the Red program consist of expressions and not values. An expression groups one or more values, and may be formed in three ways: as an application of a (prefix) function, as an infix expression which uses an operator, or as a binding of a word to refer to a value.

Functions in Red always have a fixed number of arguments (fixed arity), as opposed to Python, where one can have default arguments and variable-length arguments. Functions are called by their name followed by the arguments – no need of parentheses nor commas.

----
print  “Hello, world!”
add 2 3
find "Red" #"e"
----

Operators are always binary operations, like `+` (addition), `-` (subtraction) and so on.

Evaluation of the operands of operators has precedence over function application and binding. There is no precedence between any two operators. This is different from Python, where the operators have different link:/https://docs.python.org/3/reference/expressions.html#operator-precedence[precedence]

----
2 + 2      ; evaluates to 4
2 + 3 * 4   ; evaluates to 20, not 14!
max 3 + 4 5   ; evaluates to 7
----

As you may have guessed, `;` starts a comment until the end of the line. 
Let’s take for example the following expression:

----
square-root 4 + 5
----

The operator `+` has precedence over the function `square-root` and that’s why Red first adds 5 to 4 and only then finds the square root of 9, resulting in 3.0.

Since the function arguments aren’t enclosed in parentheses, a programmer must know the arity of the functions. 

Evaluation order can be changed by the use of parentheses: 

----
2 + (3 * 4)    ; evaluates to 14
(length? "abcd") / 2
----

If we had written `length? "abcd" / 2`, it would have resulted in an error, because Red would first try to divide “abcd” by 2.

== link:/https://github.com/red/docs/blob/master/en/datatypes.adoc[Datatypes]

Red has a rich set of datatypes. Here are some types to start with:

=== integer!

32-bit numbers with no decimal point.

`1234, +1234, -1234, 60'000'000`

=== float!

 64-bit positive or negative number that contains a decimal point.

`+123.4, -123.4, 0042.0, 60'000'12'3.4`

=== logic!

Boolean values

`true false, yes no, on off`

* set-word! - Sets a reference to a value.

`text: "Python and Red"`

=== char!

Unicode code points.

`#"a", #"^C", #"^(esc)"`

=== string!

Sequence of Unicode code points (char! values) wrapped in quotes.

`“Red”`

Unlike “Python”, strings in Red are mutable. 
For  example, compare this Python code
----
>>> txt = "abcd"
>>> txt.upper()
'ABCD'
>>> txt
'abcd'
----
with Red:
----
>> txt: "abcd"
== "abcd"
>> uppercase txt
== "ABCD"
>> txt
== "ABCD"
----

Multiline strings are enclosed in {} and can contain double-quotes:
`{This text is
split in "two" lines}`

=== block!

Collections of data or code that can be evaluated at any point in time. Values and expressions in a block are not evaluated by default. This is one of the most versatile Red types.

`[], [one 2 "three"], [print 1.23], [x + y], [dbl: func[x][2 * x]]`

=== paren!
Immediately evaluated block!. Evaluation can be suppressed by using quote before a paren value. Unquoted paren values will return the type of the last expression.

`(1 2 3), (3 * 4), (x + 5)`

Please note that if `x` doesn’t have a value in the current context, the last example will throw an error.

=== path!

Series of values delimited by slashes /. Limited in the types of values that they can contain – integers, words or parens.

`buffer/1, a/b/c, data/(base + offs)`

Path notation is used for indexing a block. Please note that Red uses 1-based indexing.
The following Python code
----
>>> mylist = [3,1,4,2]
>>> mylist[0]
3
----

Can be written in Red as follows:
----
>> mylist: [3 1 4 2]
== [3 1 4 2]
>> mylist/1
== 3
----

One can access the nested values in a block using as many levels of `/` as needed:

----
>> a: [1 [2 3] "456"]
== [1 [2 3] "456"]
>> a/1
== 1
>> a/2
== [2 3]
>> a/2/2
== 3
>> a/3/1
== #"4"
----

=== map!

Associative array of key/value pairs (similar to Python's dictionary)

`#( ), #(a: 1 b: “two”)`

The keys can be any type of the following link:/https://github.com/red/docs/blob/master/en/typesets.adoc[typesets]: 
link:/https://github.com/red/docs/blob/master/en/typesets.adoc#scalar[scalar!], link:/https://github.com/red/docs/blob/master/en/typesets.adoc#all-word[all-word!], link:/https://github.com/red/docs/blob/master/en/typesets.adoc#any-string[any-string!]

=== object!

Named or unnamed contexts that contain word: value pairs.

----
xy: make object! [
    x: 45
    y: 12
    mult: func[k][x + y * k]    
]
----
Please not that at this time it is not possible to extend an object with new word: value pairs.
The objects in Red are prototype-based, and not class-based. 
You can create a new object `xyz` using `xy` as a prototype and describe just the new pairs:

----
>> xyz: make xy [z: 1000]
== make object! [
    x: 45
    y: 12
    mult: func [k][x + y * k]
    z: 1000
]
----

=== function!

user-defined functions. Functions have specification and body:

----
x+y: function [x y][x + y]
----

There are also other kinds of functions - func, does, has - that will be explained in more details in a section dedicated to functions.

=== op!

Infix function of two arguments.

`+ - * / // % ^`

=== refinement!

Refinement! values are symbolic values that are used as modifiers to functions or as extensions to objects, files, urls, or paths.

----
>> replace/all "Mississippi" #"i" #"e"
== "Messesseppe"
----

Without the `/all` refinement only the first "i" would be changed to "e".

=== pair!

Two-dimensional coordinates (two integers separated by a `x`)

`1x2, -5x0, -3x-25`

The pair fields can be accessed by /x and /y refinments (or /1 and /2)
`+, -, *, /, %, //, add, subtract, multiply, divide, remainder, and mod` can be used with pair! values.


=== date!

Calendar dates, relying on the Gregorian calendar.

`28-03-2021, 28/Mar/2021, 28-March-2021, 2021-03-28`

As you can see, different input formats for literal dates are accepted. 

The fields of any `date!` value can be accessed using path accessors - `/date`, `/year`, `/month`, `day` (or alternatively just `/1` `/2` `/3` `/4`) 

One can use addition and subtraction operations with date!, as well as with date! and integer!. Dates will be explored in a special section.

=== tuple!

Three to twelve positive integers separated by decimal points. Used for representing RGB and RGBA color values, ip addresses, and version numbers. 

`255.255.255.0`


== Blocks and series

A block is a set of values arranged in some order. They can represent collections of data or code that can be evaluated upon request. Blocks are a type of link:/https://github.com/red/docs/blob/master/en/typesets.adoc#series[series!] with no restriction on the type of values that can be referenced. A block, a string, a list, a URL, a path, an email, a file, a tag, a binary, a bitset, a port, a hash, an issue, and an image are all series and can be accessed and processed in the same way with the same small set of series functions

Blocks in Red are similar to Python’s lists, but don’t forget that blocks are not evaluated until it’s necessary. Compare these code snippets:

Python
----
>>> p_list=[2+3,5]
>>> p_list
[5, 5]
----

Red

----
>> red-block: [2 + 3 5]
== [2 + 3 5]
----

As you can see, red-block remains unchanged, while p_list is formed by the evaluated values of its constituents.

=== Creating blocks

Blocks are created by enclosing values (separated by whitespaces) in square brackets `[ ]`

----
[1 2 3]
[42 6 * 7 “forty-two” forty two]
----

Except literally, blocks can be created at runtime using a `make` constructor: 

----
>> make block! 20
== []
----

The above code creates and empty block pre-allocated for 20 elements.

Block can also be created by converting other values:

----
>> msg: "send %reference.pdf to mail@site.com at 11:00"
== "send %reference.pdf to mail@site.com at 11:00"
>> type? msg
== string!
>> to block! msg
== [send %reference.pdf to mail@site.com at 11:00:00]`
----

Here `msg` is of string! type. When converted to a `block!`, each part of the string is converted to a Red value (of course if it represents  a valid Red value):

----
>> foreach value to block! msg[print [value  ":" type? value]]
send : word
reference.pdf : file
to : word
mail@site.com : email
at : word
11:00:00 : time
----

The above code iterates over the items of the block created from a string using `to` conversion and prints the value and its type.

Please note that `to` function (technically it’s an link:/https://github.com/red/docs/blob/master/en/datatypes/action.adoc[`action!`]) expects a datatype OR an example value to which to convert the given value. This means that instead of `block!` we can use any literal block, even`[]`:

----
>> to [] msg
== [send %reference.pdf to mail@site.com at 11:00:00]
----

=== Accessing block elements

Now that you know what a block is and how you create one, let’s try to access block’s items. Let’s work with ` data: [3 1 4 1 5 9]`.  The simplest way one can reference an item in a block is using the item’s index in the block. Unlike Python, Red uses 1-based indexing. So, to get the first item we use `path notation` and an integer index:

----
data/1
== 3
>> data/2
== 1
----

Alternatively, we can use `pick`:

----
>> pick data 3
== 4
----

Please note that in Red it’s not possible to use `path notation` to index a literal block (or series). It’s perfectly valid to write in Python:

----
>>> [2,3,1][2]
1
----

To achieve a similar behavior in red we use `pick`:

----
>> pick [2 3 1] 3
== 1
----

A useful feature of `pick` is the possibility to use a `logic!` value for the index. The `true` value refers to the first item in the block (series) and the `false` value – to the second item.

----
>> pick data 2 > 3
== 1
>> pick data 2 < 3
== 3
----

Speaking of first and second items of a block, Red has predefined functions for accessing the first 5 items of a series:

----
>> first data
== 3
>> second data
== 1
>> third data
== 4
>> fourth data
== 1
>> fifth data
== 5
----

Let’s consider another block of values: ` signal: [a 2 7 b 1 8 c 2 8] `. Here `a b c` are just `word!`s – that is they represent themselves until they 	have some value in some context. 

----
>> first signal
== a
----

So , the first item if `signal` is just `a`. 

----
>> type? first signal
== word!
----

If we try to get the value `a` refers to, we get an error:

----
>> get first signal
*** Script Error: a has no value
*** Where: get
*** Stack:  
----

However, if we assign `a` value in the current (global) context, the first item of `signal` will be referring to it:

----
>> a: "abc"
== "abc"
>> get first signal
== "abc"
----

Of what use are the words in a block? We can use them to mark positions in the block for an easy access:

----
== 7
>> signal/a
== 2
>> signal/b
== 1
>> signal/c
== 2
----

Alternatively, we can use `select` to find a value in a series and get the value after it:

----
>> select signal 'a
== 2
>> select signal 2
== 7
>>
----

=== Traversing a series

Let’s try to navigate within a block/series. Our new block will be `b: [1 2.0 #"3" "four"]`

`head` returns a series at its first index. Please note – the entire series, not the element at that position.

----
>> b
== [1 2.0 #"3" "four"]
>> head b
== [1 2.0 #"3" "four"]
----

Similarly, there is `tail` that returns a series at the index after its last value.

----
>> tail b
== []
----

Here `[]` is an empty block – there are no elements in the series at its tail.

If we are interested in the elements of a series between its head and tail, we can use `next` to iterate over the series. `next` returns a series at the next index:

----
>> next b
== [2.0 #"3" "four"]
>>
----

Please be careful - `next` doesn’t update the series, that’s why you need to use a `set-word!` to re-assign it:

----
>> next b
== [2.0 #"3" "four"]
>> b
== [1 2.0 #"3" "four"]
>> b: next b
== [2.0 #"3" "four"]
>> b
== [2.0 #"3" "four"]
----

Let’s compare Red’s `next` to Python’s `next()` method. 

----
>>> a = [1,'2',[1,2,3]]
>>> a_it = iter(a)
>>> next(a_it)
1
>>> next(a_it)
'2'
>>> next(a_it)
[1, 2, 3]
----

Python’s next()` returns a single element and not the list. If at any point you convert the iterator to a list using `list(a_it)` or `[*a_it]`, the iterator is exhausted and a subsequent call to `next(a_it)` raises a `StopIteration` exception. 

We said that `head` refers to the series at its first index – index 1. We can check the current index of a series with `index?`

----
>> b
== [2.0 #"3" "four"]
>> index? b
== 2
>> head b
== [1 2.0 #"3" "four"]
>> index? head b
== 1
>> index? tail b
== 5
----

Don’t forget that `tail` returns the series at the index after its last item. So `index? tail b` returns one more than the length of `b`.

We can find the length of a series using `length?`:

----
>> length? b
== 4
----

We can check if a series is at its head (first index) or tail with `head?` and `tail?` respectively:

----
>> b
== [1 2.0 #"3" "four"]
>> head? b
== true
>> b: next b
== [2.0 #"3" "four"]
>> head? b
== false
>> b: tail b
== []
>> tail? b
== true
----

We saw that we can go from head to tail in a series using `next`. Similarly, we can go backwards with `back`:

----
>> b
== [1 2.0 #"3" "four"]
>> tail b
== []
>> back tail b
== ["four"]
----

Both `next` and `back` change the current index of a series one step at a time. In contrast, `skip` allows bigger “jumps” relative to the current index. 

----
>> head? b
== true
>> skip b 2
== [#"3" "four"]
----

The series is at its head (first index) and we are `skip`ping 2 indices. The result is the series 2 indices after its head:

----
>> index? skip b 2
== 3
----

Don’t forget that the series head has index 1. We can use negative offset as a second argument to `skip`:

----
>> skip tail b -2
== [#"3" "four"]
----

We start at the tail of `b` and go two steps backwards, we will get the series two indices before its tail.

----
>> index? tail b
== 5
>> index? skip tail b -2
== 3
----

Please note that `skip`, `next` and `back` don’t go beyond series’ head/tail:

----
>> index? skip b 20
== 5
>> index? skip tail b -20
== 1
>>
----

The `at` functions has functionality similar to `skip`, but returns the series at a given index, instead of at an offset (relative to the current index).

----
>> head? b
== true
>> skip b 1
== [2.0 #"3" "four"]
>> at b 1
== [1 2.0 #"3" "four"]
----

`at` allows a negative integer for its `index` argument:

----
>> at tail b -1
== ["four"]
----

We will finish our tour of series navigation functions with `offset?`. Not surprisingly, It returns the offset between two series positions.

----
>> offset? b tail b
== 4
>> b
== [1 2.0 #"3" "four"]
>> subtract index? tail b index? b
== 4
----

As you can see, `offset?` is the difference between two indices in a series. 

=== Finding values in series

=== Getting several values from a series at once
 
We saw how one can access a single value from a series using index and path notation, `pick` and `select`. It is very often necessary to get more than one value from a series at once. In such cases we use `copy`.
 
----
>> c: copy b
== [1 2.0 #"3" "four"]
----
 
Here we created a new series `c` with values that are copies of the values of `b`. If we just used a `set-word!` without the `copy` function,  we would have created a reference to `b`. In such case any change in either `b` or `c` would result in changing the other, as they share a single series:
 
----
>> b
== [1 2.0 #"3" "four"]
>> c: b
== [1 2.0 #"3" "four"]
>> b/1: 11
== 11
>> b
== [11 2.0 #"3" "four"]
>> c
== [11 2.0 #"3" "four"]
----

If want to copy just a part of the series, we can use `copy` with refinement `/part`. The first argument indicates where to start, the second – how many elements to copy.

----
>> b: [1 2.0 #"3" "four"]
== [1 2.0 #"3" "four"]
>> copy/part b 2
== [1 2.0]
>> copy/part at b 2 2
== [2.0 #"3"]
>> copy/part tail b -3
== [2.0 #"3" "four"]
>>
----

In the second example we start not at the head of the series, but at its second index.

You can think of `copy/part` as using Python slices:

----
>>> a=[1,2.0,'3','four']
>>> a[:2]
[1, 2.0]
>>> a[-3:]
[2.0, '3', 'four']
----

You might be now wondering if it’s possible to mimic Pythons slicing with a step in Red. Python does it using the third parameter of the slice notation.


----
a[::2]
[1, '3']
----

Red uses a different function for this - `extract`:

----
>> extract b 2
== [1 #"3"]
>> extract next b 2
== [2.0 "four"]

----

=== Adding element to a series

Until now we were only taking elements from a series. Let’s see how to add new items. If we need to add one or more elements at the tail of a series, we do it with `append`:

----
>> append b 5
== [1 2.0 #"3" "four" 5]
----

We can append several copies of the element using `/dup` refinement:

----
>> append/dup b 6 3
== [1 2.0 #"3" "four" 5 6 6 6]
----

Python has two separate methods for adding new elements to a list as a single value or multiple values - `append()` and `extend()

----
>>> a=[1,2,3,4]
>>> a.append(5)
>>> a
[1, 2, 3, 4, 5]
>>> a.append([6,7])
>>> a
[1, 2, 3, 4, 5, [6, 7]]
>>> a.extend([8,9])
>>> a
[1, 2, 3, 4, 5, [6, 7], 8, 9]
----

Red uses the `/only` refinement to append the new value as block:

----
>> a: [1 2 3 4]
== [1 2 3 4]
>> append a [5 6]
== [1 2 3 4 5 6]
>> append/only a [7 8]
== [1 2 3 4 5 6 [7 8]]
----

We can add elements at any position in a series using `insert`

---- 
>> b: [1 2.0 #"3" "four" 5 6 6 6]
== [1 2.0 #"3" "four" 5 6 6 6]
>> insert b 'zero
== [1 2.0 #"3" "four" 5 6 6 6]
>> b
== [zero 1 2.0 #"3" "four" 5 6 6 6]
>> insert/only at b 2 [2]
== [1 2.0 #"3" "four" 5 6 6 6]
>> b
== [zero [2] 1 2.0 #"3" "four" 5 6 6 6]
----

Please note that we need to use the `only` refinement when we need the new element be added as a block, otherwise the block contents would be added.

=== Removing items from a series

We can remove values from a series using `remove`:

----
>> s: "Hello world!"
== "Hello world!"
>> remove s
== "ello world!"
>> s
== "ello world!"
>>
----

`remove`  returns the series at the same index after removing
In Python you use `del` to remove an item at the specified index (I’ll mention `pop()` in a subsequent section):

----
>>> a=[3,1,4,1,5]
>>> del a[2]
>>> a
[3, 1, 1, 5]
----

The argument can be a series at some specific index:

----
s: "Hello world!"
== "Hello world!"
>> remove at s 6
== "world!"
>> s
== "Helloworld!"
----

If we need to remove more than one value, we can use the `/part` refinement:

----
>> remove/part at s 6 3
== "ld!"
>> s
== "Hellold!"
>>
----

One way to do this in Python is to use `del` with list slicing, like `del a[2:5]`
Sometimes the whole series should the emptied, or all elements after certain index to be removed. It can be done with `remove/part`, but there is a special function for this - `clear`. It removes series values from current index to tail and returns the new tail.

----
>> s: "Hello world!"
== "Hello world!"
>> clear at s 6
== ""
>> s
== "Hello"
----

There are cases when you need to append a value to a series if it’s not found in the series, otherwise remove it. Red uses `alter` for this operation.

----
a: [1 2 3 4 5 4]
== [1 2 3 4 5 4]
>> alter a 4
== false
>> a
== [1 2 3 5 4]
----
In this example there were two 4. `alter` removed the first one and returned `false` - this means that the value has been removed and not added.

=== Changing values in series

To change a value (or consecutive values) in Red we use `change`. We need to indicate the series we want to change and the new value. If we give a single value, the value at the current index of the series will be changed to the new value:

----
>> a: [3 1 4 1 5]
== [3 1 4 1 5]
>> change at a 2 10
== [4 1 5]
>> a
== [3 10 4 1 5]
>>
----

This corresponds to Python’s assignment that refers to the item’s index within a list:

----
>>> a=[3,1,4,1,5]
>>> a[1]=10
>>> a
[3, 10, 4, 1, 5]
----

If the new value is a block, Red will change the values starting at the current index with the values from the block, appending the new values if needed:

----
>> b: [2 3 1]
== [2 3 1]
>> change at b 2 [4 5 6 7]
== []
>> b
== [2 4 5 6 7]
----

In contrast, Python changes a single value with a single value, keeping the list:

----
>>> b=[2,3,1]
>>> b[1]=[4,5,6,7]
>>> b
[2, [4, 5, 6, 7], 1]
----

If we need to do a similar thing in Red, we would use the `/only` refinement (please note how the similar actions are described with the same word - `only` in this case, analogous to `/only` in `append` and `insert`)

----
>> b: [2 3 1]
== [2 3 1]
>> change/only at b 2 [4 5 6 7]
== [1]
>> b
== [2 [4 5 6 7] 1]
----

If we need to change a given number of values with several values, we can do it with the `/part`  refinement:

----
>> b: [2 3 1]
== [2 3 1]
>> change/part at b 2 [4 5 6 7] 1
== [1]
>> b
== [2 4 5 6 7 1]
---- 

=== Replace 


=== Moving values within series

Every series is an ordered collection of elements. Sometimes we need to change the order of the elements in a block/series. In such cases, we use `move`:

----
>> a: ["red" "green" "blue" "yellow"]
== ["red" "green" "blue" "yellow"]
>> move back tail a next a
== ["blue"]
>> a
== ["red" "yellow" "green" "blue"]
----

The two arguments to `move` are just series – that’s why we can move elements from one series to another, not just from one position in a series to another position in the same series:

----
>> b: ["cyan" "magenta"]
== ["cyan" "magenta"]
>> move at a 2 b
== ["green" "blue"]
>> b
== ["yellow" "cyan" "magenta"]
----

`move` has a `/part` refinement too for moving more than one element at once.

When we need to exchange a single element between series, we use `swap`:

----
>> a
== ["red" "green" "blue"]
>> b
== ["yellow" "cyan" "magenta"]
>> swap a b
== ["yellow" "green" "blue"]
>> a
== ["yellow" "green" "blue"]
>> b
== ["red" "cyan" "magenta"]
----

=== Sorting series

A special case of moving values within series is sorting. The goal of sorting is to arrange the elements of a series according some criterion, for example a number list from smallest number to the largest. 

---- 
>> a: [53 81 67 51 13 4 3 71 48 92]
== [53 81 67 51 13 4 3 71 48 92]
>> sort copy a
== [3 4 13 48 51 53 67 71 81 92]
>> a
== [53 81 67 51 13 4 3 71 48 92]
---- 

When used without refinemens, `sort` arranges the items in ascending order, as it’s seen from the example above. `sort` modifies the series, that’s why you need to make a copy of your data if you still need the original arrangement.  The Python analogues are as follows:


. Sorting in Python and Red
[cols="1,1"] 
|===
|Python |Red

|list.sort()
|sort list

|sorted(list)
| sort copy list
|===


When you need to sort in descending order, use the `/reverse` refinement:

---- 
>> days: ["Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday"]
== ["Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" ...
>> probe sort/reverse days
["Wednesday" "Tuesday" "Thursday" "Sunday" "Saturday" "Monday" "Friday"]
== ["Wednesday" "Tuesday" "Thursday" "Sunday" "Saturday" "Monday" "Friday"] 
---- 

You can sort just the initial part of a series using the `/part` refinement:

---- 
>> text: ["Lorem" "ipsum" "dolor" "sit" "amet," "consectetur" "adipiscing" "elit."]
== ["Lorem" "ipsum" "dolor" "sit" "amet," "consectetur" "adipiscing" "elit."]
>> sort/part text 5
== ["amet," "dolor" "ipsum" "Lorem" "sit" "consectetur" "adipiscing" "elit."]
---- 

You can see that only the first five words have been sorted and the remaining block stayed unsorted.

An interesting feature of `sort` is that it can treat the series as a set of fixed size records. Let’s illustrate this concept with the following example. Let’s assume we have the following `map` 

---- 
>> id-name-map: #(3 “John” 5 “Johan” 1 “Ivan” 2 “Jean” 4 “Giovanni” 6 “Juan”)
== #(
    3 “John”
    5 “Johan”
    1 “Ivan”
    2 “Jean”
    4 “Giovanni”
    6 “Juan”
)
>> id-name-map/3
== “John”
>> id-name-block: to block! id-name-map
== [
    3 “John” 
    5 “Johan” 
    1 “Ivan” 
    2 “Jean” 
    4 “Giovanni” 
    6 “Juan...
>> id-name-block/3
== 5
>> sort/skip id-name-block 2
== [
    1 “Ivan” 
    2 “Jean” 
    3 “John” 
    4 “Giovanni” 
    5 “Johan” 
    6 “Juan...
---- 

`id-name-map` is a `map` that associates an id to a name (note that it’s not guaranteed that the key-value pairs are in any specific order in a map; `sort` doesn’t work on maps). We convert the map to a block. The block `id-name-block` is flat and id – name pairs are preserved. We sort the block using the `/skip` refinement with value 2 – that is `sort` treates the block as a set of records with size 2 by their first firld. It sorts the `id` s and the names “associated” with them. 

When we treat a series as fixed size records, we can also use `/all` - it compares all fields.

It is possible to use `/compare` refinement. It accepts a number (offset) or a function. When the argument to `/compare` is an offset, we also need to use the `/skip` refinement, because it supposes we treat the series as fixed size records. It uses the offset to sort the records by their `n` th field, where `n` is the argument to `/compare`.

---- 
>> shapes: [
[        triangle 50 255
[        rectangle 225 340
[        square 200 200
[    ]
== [
    triangle 50 255 
    rectangle 225 340 
    square 200 200
]
>> sort/skip/compare copy shapes 3 1
== [
    rectangle 225 340 
    square 200 200 
    triangle 50 255
]
>> sort/skip/compare copy shapes 3 2
== [
    triangle 50 255 
    square 200 200 
    rectangle 225 340
]
>> sort/skip/compare copy shapes 3 3
== [
    square 200 200 
    triangle 50 255 
    rectangle 225 340
]
---- 

We have a block of 9 values, which we want to treat as records of size 3 – that is the name of the shape, it’s `x` coordinate and it’s `y` coordinate. ` sort/skip/compare copy shapes 3 1` sorts the block as records of size 3 (`/skip` and parameter 3) by the 1st value of each record (`/compare` with argument 1). The next examples demonstrate sorting according to the 2nd (`x` coordinate) and 3rd (`y` coordinate) fields.

When the argument to the `/compare` refinement is a function, it needs to be a function with exactly 2 arguments, because it will be called for each two elements that are currently sorted. We’ll talk about functions in more details in a dedicated section. For the moment let’s just sort a block of strings according to their length:

---- 
colors: ["transparent" "gray" "red" "white" "beige" "aqua" "black" "blue"]
sort/compare colors func[x y][(length? x) <  length? y]
== ["red" "gray" "blue" "aqua" "black" "white" "beige" "transparent"]
---- 

I’ve used an anonymous function with two arguments `x` and `y`, that compares wherher the length of the first argument is less than the length of the second. `sort` used this function an argument for the `/compare` refinement and sorted the strings according the comparison in the function.

=== Taking elements from series

We saw that we could remove elements from series. Sometimes we need to use these elements and not just discard them. This is done using `take`:

----
>> a
== ["yellow" "green" "blue"]
>> color: take a
== "yellow"
>> color
== "yellow"
>> a
== ["green" "blue"]
----

The element at the current index was removed from the series, and returned as result. `/part` refinement is available in `take’ too. Use `/last` when you need to take element(s) from the tail of a series. 
Python’s `pop()` is similar to Red’s `take` (with no `/part` refinement)

----
>>> a=[3,1,4,1,5]
>>> last_a=a.pop()
>>> a
[3, 1, 4, 1]
>>> last_a
5
----

----
>> a: [3 1 4 1 5]
== [3 1 4 1 5]
>> last-a: take/last a
== 5
>> a
== [3 1 4 1]
----

=== Series as sets

Sometimes we only need to know what the series elements are, regardless of their count and order. In such cases we treat the series as a set. 
We re move the duplicates in a series using `unique`:

----
>> a: [3 1 4 1 5]
== [3 1 4 1 5]
>> unique a
== [3 1 4 5] 
>> a
== [3 1 4 1 5]
>> unique "AbracadABra"
== "Abrcd"
----

Please note that in the last example Red has removed the lowercase `a` to. By default, Red is case insensitive. In order to distinguish between uppercase ans lowercase characters, we need to use the `case` refinement:

---- 
>> unique/case "AbracadABra"
== "AbracdB"
----

The series is not updated by the call to `unique` - you need to reassign it if you want to use the result as a new value for the series.
Please note that there is no `set` datatype in Red as in Python:

----
>>> a=[3,1,4,1,5]
>>> set_a=set(a)
>>> set_a
{1, 3, 4, 5}
>>> type(set_a)
<class 'set'>
----

Red provides the following operations on data sets: `union`, `difference` and `intersect`. 

== Conditionals

As we said before, Red does not have any keywords. Where some other programming languages use special constructs for control flow, Red uses (native) functions.

=== If

When we want to execute some code depending on a condition, we use `if `. It expects two arguments:  a conditional expression and a block to evaluate. If the conditional expression is true, the block is evaluated, otherwise the function returns none.
Using blocks as code is a common pattern in Red. Blocks stay unevaluated until feeded into some function. 

----
>> hooray!: [print "Weekend at last!"]
== [print "Weekend at last!"]
>> if now/weekday > 5 hooray!
Weekend at last!
>> now/weekday
== 6
----
`hooray!` is just a block consisting of a word! `print` and a string! “Weekend at last!”. Red just makes the `set-word!` `hooray!` to refer to the literal block that follows. At this point, `print` inside the block is just a word and doesn’t mean anything. 

The conditional expression in our example is `now/weekday > 5`. `now` is a native function that returns a value of `date!`  datatype, set to the current date and time. `/weekday` is a `refinement!` to `now` that determines which day of the week is a given date, 1 for Monday. So we simply check if the weekday is greater then Friday and if it is, we want the block that we have given as a second argument evaluated. More often the then-block argument of `if` is a literal block, but don’t forget that if could have been declared and even changed before its use. Or it can be changed after its first use and used for another purposes.

Red’s `if condition then-block` works similar to Pythons `if condition: code-block`, where code-block is either a one line of code immediately following the semicolon, or an indented block of code.

Now it’s the right time to compare the comparison operators in Python and Red:

.Comparison operators in Python and Red
[cols="1,1,2"] 
|===
|Python |Red |Name

|==
|=
|Equal to

|!=
|<>
|Not equal to

|>
|>
|Greater than

|<
|<
|Less than

|>=
|>=
|Greater than or equal to

|#<#=
|#<#=
|Less than or equal to

|===


Note that the simple comparison is just `=` in Red. There is `==` too, but it performs a stricter comparison, taking also under account the datatypes of the values:

----
>> 345 = 345.0
== true
>> 345 == 345.0
== false
---- 

`not` is used when we need to reverse the meaning of a Boolean expression. Remember that booleans are a `logic!` type in Red. True is indicated by any one of `true, on, yes`; False – by any one of `false, off, no`. 

---- 
>> not true
== false
>> not off
== true
>> not not no
== false
>> not 10 > 20
== true
----

=== Unless
You can write `if not condition`, but there is a convenient function for this pattern, `unless`:

---- 
>> a: 10
== 10
>> unless a >= 20 [print "a is less then 20"]
a is less then 20
---- 

=== Either
`if` and `unless` execute the code in the then-block when the condition is met; they do not provide an alternative. If you need to execute an appropriate code for the either Boolean results of a condition, you use `either`:

---- 
>> print either now/weekday > 5 ["Weekend"]["workday"]
workday
---- 

As you can see, `either` corresponds to Pythons `if-else` statement – if the condition is true, the first block is executed, otherwise – the second one.

If you need to reproduce the Pythonic `if-elif-else`, you’ll need to cascade two or more `eiter` function calls: `either cond1 [true-block-1][either cond2[true-block-2][false-block]]`.

=== Case

Sometimes you need to select one block of code to execute from many, based on which one has a true condition.

---- 
color: "Red"
RYB-type: case [
    find ["Red" "Yellow" "Blue"] color ["Primary color"]
    find ["Orange" "Green" "Purple"] color ["Secondary color"]
    find ["Vermilion" "Amber" "Chartreuse" "Teal" "Violet" "Magenta"] color ["Tertiary color"]
]
print RYB-type
---
Primary color
---- 

The syntax is `case block`, where `block` is a block of pairs, each pair consisting of condition and block to execute. `case` evaluates the block after the first true condition.
One important thing to remember about `case` is that the pairs don’t have to be connected in any way. There’s a `/all` refinement, that evaluates the block after every true condition.

---- 
color: "Teal"
case/all [
    true [prin [form color " is a "]]
    find ["Red" "Yellow" "Blue"] color [print "Primary color"]
    find ["Orange" "Green" "Purple"] color [print "Secondary color"]
    find ["Vermilion" "Amber" "Chartreuse" "Teal" "Violet" "Magenta"] color [print "Tertiary color"]
true [print "Analysls complete! "]
]
---
Teal  is a Tertiary color
Analysls complete!
----

=== Switch

Another form of branching is achieved using `switch`. It accepts a value of any type as a first argument and a block, consisting of any number of value – block pairs as its second argument. The block after the value that matches the first argument is evaluated.

---- 
n: 2
switch n [
    1 ["one"]
    2 ["two"]
    3 ["three"]
]
---
"two"
---- 

If the value is not found in the block, `switch` returns `none`. If you need it to return some specific value in case the first argument is not found, use `/default` refinement:

---- 
color: "Orange"
switch/default color [
    "Blue" [0.0.255]
    "Red" [255.0.0]
    "Beige" [255.228.196]
] [0.0.0]
--- 
0.0.0
---- 

Python doesn’t have a `switch` or `case` statement yet (Python 3.10 is going to have a `match/case` syntax. Until then you can use `if/elif/else` statement, or use a `get()` method with a dictionary as a workaround.

=== Or, and, xor, any, all

Very often the Boolean condition is not a simple one but compound, consisting of different parts combined using logcal operators. We already used `not`, which returns the logical complement of a value. 

`or` returns `true` if either of the arguments or both of them are true.

---- 
>> a: 10
== 10
>> a > 0 or (a < 20)
== true
---- 

Please note the use of parentheses around the right hand side argument of `or`. This is due to the fact that `or` is an op! (infix function) and there is no precedence. The left-hand side argument is if type `logic!` (`a > 0` is evaluated to `true`) and if there were no parentheses, Red would have tried to calculate `true or a` first. But `a` is a number and that would have resulted in an error.

`and` returns `true` only if both arguments are `true`.

`xor` returns true if only one of the arguments is true.

`or`, `and` and `xor` are also used for the bitwise operations on numbers.

Sometimes there are a lot of conditons that should be combined. It is often more convenient to use `all`/`any` functions. Let’s change our last example so that it uses `all`:

---- 
>> all [a > 0 a < 20]
== true
---- 

So, `all` takes a block of values, evaluates them and returns `true` if they are all true, or `none` otherwise. 

In order to demonstrate `any`, let’s pretend that we want to check if a given point is outside of a given rectangle. The point is defined as a `pair!` of integers and the rectangle – as two pairs of integers (it’s top-left and bottom-right corners).

---- 
p: 50x23	; point with x = 50,  y = 23
tl: 40x40	; top-left corner, x = 40, y = 40
br: 100x100	; bottom-right corner, x = 100, y = 100
any [
    p/x < tl/x
    p/y < tl/y
    p/x > br/x
    p/y > br/y
]
 ---
true
---- 

The `y` coordinate of our point is less than the `y` coordinate of the top-left corner of the rectangle. Only this condition is true, but it is sufficient to know that the point lies outside of the rectangle.

Be carefull when you try to apply some patterns you may have adopted with Python: in Python empty strings / lists / tuples / dictionaries etc. have `falsy` Boolean values, zero numeric values – too. This is not the case in Red:

---- 
>> to logic! []
== true
>> to logic! ""
== true
>> to logic! #()
== true
>> to logic! 0
== true
>> to logic! 0.0
== true
---- 

On the other hand, the Boolean value of `none` is `false`:

----
>> to logic! none
== false
----
 
== Loops

=== Loop

The simplest of the looping constructs in Red is `loop`. It takes a value (an integer! or a float! – that is automatically truncated to an integer) and a block as its arguments and evaluates the block as many times as the value. Of course the value can be a word and not just a literal numeric value.

---- 
>> loop 5 [print "I Am a Strange Loop"]
I Am a Strange Loop
I Am a Strange Loop
I Am a Strange Loop
I Am a Strange Loop
I Am a Strange Loop
---- 

=== Repeat

`repeat` is the more useful cousin of `loop`. It evaluates a given block a predefined number of times, while a loop counter keeps a track of the iterations. The starting value of the counter is 1.

---- 
>> n: 4
== 4
>> repeat count n [print["Iteration number" count]]
Iteration number 1
Iteration number 2
Iteration number 3
Iteration number 4 
---- 

Here `n` is the number of times to evaluate the block and `count` is the iteration counter.

You can think of `repeat x y []`  as Python’s `for x in range(y): …` (Just don’t forget that Red starts the repeat counter at 1):

---- 
>>> for n in range(5): print(n)
0
1
2
3
4
---- 

=== While

When it’s not known in advance how many times a loop will be exexcuted, it’s a good idea to use `while` or `until`. `while` takes a condition-block and a body-block as arguments and evaluates the body as long as the condition evaluates to truthy value.

---- 
>> text: "Red is a next-gen programming language, strongly inspired by REBOL "
== {Red is a next-gen programming language, strongly inspired by REBOL }
>> while [not empty? text][print take/part text index? find text space]
Red 
is 
a 
next-gen 
programming 
language, 
strongly 
inspired 
by 
REBOL 
---- 

In the example above the condition block is `[not empty? text]` - we simply check if there are still some characters left  in `text` and if there are, we evaluate the body. We find the next space in `text`, get its index, and take (remove) and print this part (substring) of `text`. After each step the condition is checked and if it’s still true, the body is evaluated again.

`while` loop in Red is analogous to Python’s `while` loop.

=== Until
In contrast to `while`, `until` requires only one block. The block is evaluated until the last value in the block is true. This means that the block is executed at least once, whereas with `while` the execution of the block can be skipped altogether. 

Let’s‘ see `until` in action with the follwong example. It demonstrates a simple conversion of a number from decimal to binary number system:

---- 
num: 13
base: 2
digits: copy []
until [
   insert digits num % base
   zero? num: to-integer num / base
]
---- 

---- 
>> probe digits
[1 1 0 1]
---- 

`num` is the number we want to convert to binary, `base` is the new number system base (changing it allows for the code to work for other number systems) and `digits` is an empty block that will contain the digits after conversion. We start a `until` loop, find the remainder from dividing the current value of `num` to `base` and insert the remainder to the head of `digits` (I inserted  the elements instead of appended them because otherwise I would need to reverse the block at the end). Then I find the new value of num by dividing it by `base` and casting it to an integer. The last value in the block is the result of checking `num` against `0` with `zero?`.  If it is false (`num` is not zero), we are not finished yet, so we loop again with the new value of `num`; otherwise we exit the loop.

=== Forever
Well, `forever` does what it’s name implies – loops through the block that follows and executes it indefinitely.

=== Foreach

`foreach is most probably the most frequently used looping construct in Red.  It expects three arguments as follows:

`foreach 'word series body`

`word` is a word (or block of words) that is set to the current value of the series at each iteration. `series` is the series to iterate and `body` is a block of expressions to be evaluated at each iteration. 

---- 
>> foreach toy ["car" "doll" "puppy" "robot" "teddy bear"][print toy]
car
doll
puppy
robot
teddy bear
---- 

When `word` is a block of words, that many values are taken from the series current index onward and the words are assigned that values.

---- 
>> foreach [toy qty] ["car" 2 "doll" 3 "puppy" 1 "robot" 1 "teddy bear" 2][print [toy ":" qty]]
car : 2
doll : 3
puppy : 1
robot : 1
teddy bear : 2
---- 
I’m sure you have already guessed that Red’s `foreach` is almost analogous to Python’s `for var in iterable: code`:

---- 
 >>> for toy in ["car","doll","puppy","robot","teddy bear"]: print(toy)
car
doll
puppy
robot
teddy bear
---- 

There is a slight, but important, difference though. When in Red we use a block of words, at each iteration `foreach` takes exactly as many values from the series as the number of words in the block. That is, the series is treated as a flat list and the structure of each value is not important. At the opposite, when we use `for` with two or more variables in Python, the list is expected to be constructed of lists/tuples, each with exactly the same number of items as there are variables:

---- 
>>> for toy,qty in [("car",2),("doll",3),("puppy",1),("robot",1),("teddy bear",2)]:
print(toy,qty)

car 2
doll 3
puppy 1
robot 1
teddy bear 2
---- 

Python’s `for` consumes exactly one value from the iterable at each step, no matter how many variables/items in the substructure.


=== Forall

We saw that `foreach` traverses the series, getting one value from it at a time.  We may think its functionality is similar to this code:

---- 
toys: ["car" "doll" "puppy" "robot" "teddy bear"]
repeat idx length? toys [
    print[toys/:idx]
]
--- 
car
doll
puppy
robot
teddy bear
---- 

In fact, the index/position in the series is not explicitly known with `foreach` - all we know is the current value of the series (of course we can add a counter and update it at each iteration, but that’s different story).

That’s why Red has another looping function - `forall` - that exposes the series at each iteration.

`forall 'word body` evaluates the body for all values in the series (‘word refers to series we want to iterate over).

Did you notice the `'` in front of `word`? This is very important. As you remember, I used a literal block in the `foreach` example. I could have set a word to refer to it and use it as an argument to `foreach`, that’s completely fine. There is no freedom of choice with `forall` - it must be a `word` and cannot be a literal block! The reason is simple – we use the word itself to refer to the series at each iteration (there is no additional word to set).

What `forall` does is start at the head and go to the next series at each iteration:	
---- 
>> forall toys [probe toys]
["car" "doll" "puppy" "robot" "teddy bear"]
["doll" "puppy" "robot" "teddy bear"]
["puppy" "robot" "teddy bear"]
["robot" "teddy bear"]
["teddy bear"]
== ["teddy bear"]
---- 

Did you observe the difference with `foreach`? In our example `toys` refers to the entire series, not to a particular value at some index. This means that at each iteration we know where exactly in the series are we. 
The above example can be written in Python using `for` loop with `range()` from 0 to the length of the list and a slice starting at the current loop variable at each iteration:

---- 
>>> toys = ["car","doll","puppy","robot","teddy bear"]
>>> for idx in range(len(toys)): print(toys[idx:])

['car', 'doll', 'puppy', 'robot', 'teddy bear']
['doll', 'puppy', 'robot', 'teddy bear']
['puppy', 'robot', 'teddy bear']
['robot', 'teddy bear']
['teddy bear']
---- 



We can easily use all series navigation functions with `toys` - `next back index? head? tail?` etc. inside the body of a `forall` loop:

---- 
>> forall toys[print[length? toys tail? next toys]]
5 false
4 false
3 false
2 false
1 true
---- 

`forall` loop is very useful when we want to change all the values of the series in place. Let’s consider the following simple case: we have a list of numbers and want it updated after multiplying each of them by some coefficient. 

---- 
>> a: [2 3 11 7 16]
== [2 3 11 7 16]
>> coef: 2.5
== 2.5
>> forall a[a/1: coef * a/1]
== 40.0
>> a
== [5.0 7.5 27.5 17.5 40.0]
---- 

Since `a` refers to the series as a whole, we need to tell Red that we want the item at the current index to be multiplied by the coefficient – that’s why we used `a/1`.

=== Remove-each

`remove-each 'word data body` - traverses `data`, sets `word` to the current value of `data` at each iteration and removes the current value if `body` returns a truthy value.

---- 
words: ["premium" "launch" "false" "minister" "breathe" "dawn" "raw" "earthquake" "grow" "entertainment"]
remove-each w words[(length? w) > 6]
== ["launch" "false" "dawn" "raw" "grow"]
---- 

At each iteration we check if the length of `w` is greater than 6. If it is, `remove-each` removes the value from `words`.

== Functions

Until now we have been looking at how to use Red’s predefined functions. It’s now time to learn how to define our own functions.

Functions can be created using one of the predefined words `func`, `function`, `has`, or `does`, or using `make` with `function!` as its first argument (type). Let’s start with a simple example:

---- 
square: func[n][n * n]
---- 

---- 
>> square 9
== 81
---- 

We define `square` to be a function with one argument `n`, that returns its argument squared (multiplied by itself): `n * n`. As you can see, the arguments are enclosed in a block that is the first argument to `func`. This block is said to be the function’s specification. The second block, the function’s body, contains all the expressions that the function evaluates. The last computed value in the body is returned as a result of the function. If the result should be returned earlier than the last expression in the body due to branching, we can use `return` followed by a value/expression.

Let’s see what are the differences between the four types of functions I mentioned above.

=== func

=== function

=== has

=== does

=== Function specification

=== Refinements

=== op!

=== routine!
