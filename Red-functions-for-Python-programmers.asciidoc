
The table below is based on the “Builtin Python Functions” section of https://medium.com/@robertbracco1/most-common-python-functions-aafdc01b71ef[Most Common Python Functions] article.

.Most common functions in Python and their analogues in Red
[options="header"]
|====
|Python function|Red function or code|Datatypes and typesets / Notes
|len()| <<length-notes,length?>>|series! port! bitset! map! tuple! none!
|print()|<<print-notes,print>>|any-type!
|format()|<<format-notes,N/A>>|Not yet implemented
|isinstance()|<<isinstance-notes,various>>|any-type!
|str()|<<str-notes,form>>|any-type!
|int()|<<int-notes,to-integer>>|number! string!
|range()|<<range-notes,N/A>>|Not implemented
|open()|<<open-notes,N/A>>|Not necessary
|list()|<<list-notes,N/A>>| N/A
|super()|<<super-notes,N/A>>|N/A
|set()|<<set-notes,unique>>|block! hash! string!
|dict()|<<dict-notes,to-map>>|block!
|getattr()|<<getattr-notes,get>>|object! 
|hasattr()|<<hasattr-notes,N/A>>|object!
|type()|<<type-notes,type?>>|any-type!
|float()|<<float-notes,to-float>>|string! number!
|enumerate()|<<enumerate-notes,N/A>>|N/A
|sorted()|<<sorted-notes,sort copy>>|series!
|max()|<<max-notes,max>>|scalar! series!
|====

anchor:length-notes[]
*length?*

_Python_

`len(s)` returns the length (the number of items) of an object. The argument may be a sequence (such as a string, bytes, tuple, list, or range) or a collection (such as a dictionary, set, or frozen set)

_Red_

`length?` returns the number of values in the `series!`, from the current index to the tail , or the number of elements needed to store the value, if it is of one of the following types: `port!` `bitset!` `map!` `tuple!` `none!`. 

(`series!` is a `typeset!` consisting of the following datatypes: `block!` `paren!` `string!` `file!` `url!` `path!` `lit-path!` `set-path!` `get-path!` `vector!` `hash!` `binary!` `tag!` `email!` `image!`)

---- 
>> length? [loop 10 [print "Hello World!"]]  ; a block! with 3 values
== 3
>> length? mold [loop 10 [print "Hello World!"]] ; `mold` returns a string!
== 32
>> file: %/C/ProgramData/Red/gui-console-2021-5-19-43168.exe  ; a file!
== %/C/ProgramData/Red/gui-console-2021-5-19-43168.exe
>> length? file
== 50
---- 

In the last example `file` has a value of `file!` datatype. File! values represent file names or directory names and paths. File! is a member of the following typesets: any-string!, series!, so it is kind of string. `length? file` returns the length of the string representing the file name and not the size of the file it may refer to. 

---- 
>> red-lang-doc: https://github.com/red/docs/blob/master/en/SUMMARY.adoc ;  url!
== https://github.com/red/docs/blob/master/en/SUMMARY.adoc
>> length? red-lang-doc
== 55
---- 

---- 
>> length? 'a/b/c/d/e/f/2 ; path!
== 7
>> length? to binary! "123456789" ; binary!
== 9
---- 

The length of an `image!` value is the number of its pixels: 
---- 
>> img: make image! [100x100 255.255.255]
== make image! [100x100 #{
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF...
>> length? img
== 10000   ; 100x100
----

The above examples showed the length of values that are `series!`. Let’s 

The length of the `bitset!` is computed as the smallest multiple of 8 needed to fit the highest bit number (0-origin): 

---- 
>> bits: make bitset![80 87]
== make bitset! #{0000000000000000000081}
>> length? bits
== 88
>> bits: make bitset![80 87 88]
== make bitset! #{000000000000000000008180}
>> length? bits
== 96
>> length? charset "AB"
== 72
>> length? charset "ABCDEFGH"
== 80
---- 

The length of a `map!` value is the number of its keys:

---- 
>> m: system/locale/months
== [
    "January" "February" "March" "April" "May" "June" 
    "July" "August" "Septem...
>> freq: #()
== #()
>> foreach c form m[freq/:c: 1 + any[freq/:c 0]]
== 9
>> probe freq
#(
    #"J" 3
    #"a" 5
    #"n" 2
    #"u" 6
    #"r" 9
    #"y" 4
    #" " 11
    #"F" 1
    #"e" 11
    #"b" 5
    #"M" 2
    #"c" 3
    #"h" 1
    #"A" 2
    #"p" 2
    #"i" 1
    #"l" 2
    #"g" 1
    #"s" 1
    #"t" 3
    #"S" 1
    #"m" 3
    #"O" 1
    #"o" 2
    #"N" 1
    #"v" 1
    #"D" 1
)
>> length? freq
== 27
---- 

The length of a tuple is the number of its elements:

---- 
>> img/1
== 255.255.255.0  ; rgba
>> length? img/1
== 4
---- 

If you wonder the purpose of the question mark at the end of `length?` - here’s the answer: 


[quote, Coding-Style-Guide]
Function names should strive to be single-word verbs, in order to express an action. . .   A noun or an adjective followed by a question mark is also accepted. Often, it denotes that the return value is of logic! type, but this is not a strict rule, as it is handy to form single-word action names for retrieving a property (e.g. length?, index?)

{empty} +
{empty} +

anchor:print-notes[]
*print*


_Python_ 

`print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)`
Print `objects` to the text stream `file`, separated by `sep` and followed by `end`. `sep`, `end`, `file` and `flush`, if present, must be given as keyword arguments.

_Red_

`print` outputs a value followed by a newline. If the argument is a single value, there is no need to enclose it in brackets.

---- 
>> print pi
3.141592653589793
>> numbers: [13 1 7 11 13 4 3 11 8 12]
== [13 1 7 11 13 4 3 11 8 12]
>> print numbers
13 1 7 11 13 4 3 11 8 12
>> print ["PRINT" "is" "a" "native!" "value"]
PRINT is a native! value
---- 

When the argument is a `block!`, `print` reduces it before ouput:

---- 
>> toy: "Dog"
== "Dog"
>> amount: $23
== $23.00
>> tax: 10%
== 10%
>> print["The price of" toy "is" 1 + tax * amount]
The price of Dog is $25.30
---- 

Of course all the values in a block we want to print must have values:

---- 
>> block: [a b [c d]]
== [a b [c d]]
>> print block
*** Script Error: a has no value
*** Where: print
*** Stack:
---- 

You can still print the block from the example above – you first need to `mold` it (to get its source format string representation):

---- 
>> print mold block
[a b [c d]]
---- 

In fact Red does have a built-in function that does exactly the same - `probe`:

---- 
>> probe block
[a b [c d]]
== [a b [c d]]
---- 

In addition, `probe` returns the printed value:

---- 
>> length? probe block
[a b [c d]]
== 3
---- 

When you don’t want the printed output to end with a new line, use `prin` instead of `print`: 

---- 
>> prin "Hello" print " World!"
Hello World!
---- 

Sometimes you need a new line to be inserted between the values of a single call to `print`. The newline character in Red is indicated by `#"^/"`. There are two words predefined to this value: `newline` and `lf`:

---- 
>> print ['Red "^/is a next-gen" newline 'programming lf 'language]
Red 
is a next-gen 
programming 
language
---- 


anchor:format-notes[]
*String Formatting*


_Python_

The `format()` method formats the specified value(s) and insert them inside the string's placeholder. The placeholder is defined using curly brackets: {}. The values are passed as positional and/or keyword arguments. Inside the placeholders you can add a formatting type to format the result, like alignment and number formats.

_Red_ 

Red doesn’t currently have a single function that can mimic Python’s `format()`. In most simple cases you can use `rejoin`:

---- 
>> name: "Red"
== "Red"
>> type: "full-stack"
== "full-stack"
>> rejoin [name " is a " type " programming language"]
== "Red is a full-stack programming language"
---- 

Here’s a simple function that formats a string. It takes a string as its first parameter and sets the placeholders to the corresponding named values found in the second argument – a block with “keyword” parameters:

---- 
format: function[
    {Simple string formatting. Uses a block of keyword parameters to set the values of placeholders}
    str [string!] "String to format" 
    val [block!]  "A block with set-word - value pairs"
][
    parse str[
        any[
            to remove "{" 
            change copy subs to remove "}" (select val to set-word! subs)
        ]
    ]
    str    
]
---- 

---- 
>> print format {My name is {name}. I'm {age} years old.}[age: 36 name: "John"]
My name is John. I'm 36 years old.
---- 


We can add some formatting types to the above function and make it more useful. Here’s a https://github.com/GalenIvanov/format[tiny formatting DSL].

There is much more sophisticated experimental Red dialect dedicated to formatting:  https://github.com/greggirwin/red-formatting[Red-formatting]


anchor:isinstance-notes[]
*Type checking*

_Python_
`isinstance(object, type)` returns `True` if the specified object is of the specified type, otherwise `False`.

---- 
>>> a = 123
>>> isinstance(a,int)
True
>>> text = 'Hello world!'
>>> isinstance(text,str)
True
---- 

_Red_ 

Red doesn’t have a single function to check if a value is of the specified type. Instead, there is a separate function for each datatype and typeset. This is similar to Racket’s predicate functions.

---- 
>> a: 123
== 123
>> integer? a
== true
>> number? a
== true
>> string? "Hello world!"
== true
>> any-string! any-string?
>> any-string? %orders-May-2021.csv
== true
>> block? [print now/date]
== true
>>
---- 

It is very easy to write an `isinstance` function in Red:

---- 
isinstance: function[object type][
    types: make typeset! to [] type
    find types type? :object
]
---- 

The type can be a single datatype, a typeset or a block of datatypes (can be unrelated types).
 
Here are some tests:
---- 
>> print isinstance 1.23 [integer! float!]
true
>> print isinstance 1.23 number!
true
>> print isinstance 1.23 float!
true
>> print isinstance 1.23 [string! float!]
true
>> print isinstance "1.23" string!
true
>> print isinstance %contents.pdf any-string!
true
>> print isinstance [print "Hello world!"] block!
true
>> print isinstance "1.23" number!
false
>> print isinstance 1.23  integer!
false
>> print isinstance 123 [string! float!]
false
---- 

anchor:str-notes[]
*String representation of an object*

_Python_

`str(object, encoding=encoding, errors=errors)` converts the specified value into a “readable” string. 

_Red_ 

While not 100% equivalent to Python’s `str()`, `form` is Red’s way to give a user-friendly string representation of a value.

---- 
>> form 123
== "123"
>> form "123"
== "123"
>> form [1 2 3]
== "1 2 3"
---- 

Note that the result of `form` is ambiguous – like Python’s `str()` - both integer `123` and `string`  “123”` are formed as `”123”`. The same is in Python:

---- 
>>> str(123)
'123'
>>> str('123')
'123'
---- 
 
That means that the result of `form` can’t always be loaded back to the original type of the value. 


anchor:int-notes[]
*Conversion to integer*

_Python_

`int(x, base=10)` returns an integer object from a number or string. If `base` is given, then x must be a string, bytes, or bytearray instance representing an integer literal in radix base.

_Red_

Use `to-integer value` to convert a `number!`, `char!`, `string!` or `binary!` value  to integer:

---- 
>> num: [65.78 6578% #"A" "65" #{00000041}]
== [65.78 6578% #"A" "65" #{00000041}]
>> foreach n num[print to-integer n]
65
65
65
65
65
---- 

`to-integer` is an alias for `to integer!`. It can be further shortened to `to 1` - you can use any other integer instead of 1, as well as a word that refers to an integer value.

Red doesn’t currently provide a function for integer conversion from number bases different than 10, but it is an easy task:

---- 
from-base: function[
    {Converts x from a string of chars [0-9 A-Z] in radix base to decimal}
    x    [string!]
    base [integer!]
][
    c: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    n: 0
    foreach i x[n: n * base - 1 + index? find c i]
]
---- 

Here are some tests:

---- 
>> print from-base "1101" 2
13
>> print from-base "FF" 16
255
>> print from-base "9IX" 36
12345
---- 

anchor:range-notes[]
*Ranges*

_Python_

The range type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops. 

`range(stop)` or `range(start, stop[, step])` 

_Red_

Red doesn’t have a built-in solution that covers the functionality of Python’s `range()` sequence. It is easy to write a function that generates a list of numbers in a range, that is Python’s `list(range(x))`. Here’s one way to do it:

---- 
range: function[
    _end [integer!]
    /from 
        start [integer!]
    /by
        step  [integer!]
][
    _start: either from[_end][1]
    _end: either from[start][_end]
    step: any [step 1]
    rng: make block! (absolute _end - _start / step)
    cmp?: get pick[<= >=]step > 0
    
    while[_start cmp? _end][
        append rng _start
        _start: _start + step
    ]
    rng
]
----  
Here are some tests:

---- 
>> probe range 10
[1 2 3 4 5 6 7 8 9 10]
>> probe range/from 2 10 
[2 3 4 5 6 7 8 9 10]
>> probe range/from/by 10 20 2
[10 12 14 16 18 20]
>> probe range/from/by 50 10 -5
[50 45 40 35 30 25 20 15 10]
>> probe range/from/by 5 -5 -1
[5 4 3 2 1 0 -1 -2 -3 -4 -5]
---- 

Here’s a more elaborated https://gist.github.com/toomasv/0e3244375afbedce89b3719c8be7eac0[Range function for multiple datatypes]

Puthon’s `range()` returns an immutable sequence and can be used directly with `for`, `zip`, `enumerate` and other constructs/functions. It can also be passed to `iter()` and then its elements accessed sequentially with `next()` until exhaustion. A range object can be converted to a list with `list()`. 

Lets’ try to make a function `lazy-range` in Red that does not generate the entire list at once but create a range object. `lazy-range` will accept the same arguments as our earlier `range` function. It returns a single element when request with `/next?`. The `/size` field contains the total number of elements. Unlike Python, I added a `/reset` field that resets the current element to the starting value. There is also a `/list` field that generates a list of all the elements in the range from the current element to the end.

---- 
lazy-range: function[
    _end [integer!]
    /from 
        start [integer!]
    /by
        step  [integer!]
][
    _start: either from [_end][1]
    _end:   either from [start][_end]
    _step:  any [step 1]

    l-range: make object! [
        start: _start
        end:   _end
        step:  _step
        curr:  start
        size:  absolute end - start + step / step
        cmp?:  get pick[< >]step > 0 

        next?: does [
            also curr curr: either all[not none? curr curr cmp? end][
                curr + step
            ][
                none
            ]
        ]
        
        reset: does [curr: start]
        list: does[collect[while[not none? curr][keep next?]]]
    ]
]
---- 

Let’s make some tests:

---- 
>> r: lazy-range 10
== make object! [
    start: 1
    end: 10
    step: 1
    curr: 1
    size: 10...
>> r/next?
== 1
>> r/next?
== 2
>> r/next?
== 3
>> r/list
== [4 5 6 7 8 9 10]
>> r/next
== none
>> r/reset
== 1
>> r/next
== 1
---- 

---- 
>> even20: lazy-range/from/by 2 20 2
== make object! [
    start: 2
    end: 20
    step: 2
    curr: 2
    size: 10...
>> even20/list
== [2 4 6 8 10 12 14 16 18 20]
>> even20/reset
== 2
---- 


anchor:open-notes[]
*Open file*

_Pyton_
Open file and return a corresponding file object. If the file cannot be opened, an OSError is raised.

_Red_
In Red you don’t need to make a call to a special function to open a file, you just do what you need with the file – read, write and so on. The binary mode is indicated with `/binary` refinement.


anchor:list-notes[]
*List cosntructor*

_Python_

`list()` takes an iterable object as input and adds its elements to a newly created list.

_Red_

`to-block` conversion does similar job for some datatypes – it is convenient to use with `map!` and `path!` values:

---- 
>> user: #(name: "Peter" id: 43152)
== #(
    name: "Peter"
    id: 43152
)
>> to-block user
== [
    name: "Peter" 
    id: 43152
]
>> path: 'object/prop/coords/top-left
== object/prop/coords/top-left
>> to-block path
== [object prop coords top-left]
---- 

Here’s a simple function that takes a value and returns a block of values:

---- 
list: function[
    src  
    /into
        buf
][
    dst: any [buf make block! 100]
    
    append dst switch/default type?/word src [
        string! 
        tuple! 
        binary! 
        bitset! [collect[repeat idx length? src[keep src/:idx]]]
        pair!   [reduce [src/x src/y]]
        file!
        url!    [parse src[collect[any[keep to[some "/" | end] some "/"]]]]
        date!   [collect[repeat idx 14[keep src/:idx]]]
    ][
        to-block src
    ]
]
---- 

Let’s do some tests with compound and scalar datatypes:

---- 
foreach value compose [
    [Red functions for Python programmers]
    #(name: "Peter" id: 43152)
    'system/locale/months
    "Hello world"
    (to-binary 123456)
    (make bitset! [1 2 3 5 6])
    3.1.4.1.5
    23x45
    %"/C/Program Files/GIMP 2/bin/gimp-2.10.exe"
    https://github.com/red/docs/blob/master/en/typesets.adoc#series
    (now)
    42
    110%
][print [mold value lf type? value lf mold list value lf]]  
---- 

---- 
[Red functions for Python programmers] 
block 
[Red functions for Python programmers] 

#(
    name: "Peter"
    id: 43152
) 
map 
[
    name: "Peter" 
    id: 43152
] 

'system/locale/months 
lit-path 
[
    system locale months
] 

"Hello world" 
string 
[#"H" #"e" #"l" #"l" #"o" #" " #"w" #"o" #"r" #"l" #"d"] 

#{0001E240} 
binary 
[0 1 226 64] 

make bitset! #{76} 
bitset 
[true true true false true true false false] 

3.1.4.1.5 
tuple 
[3 1 4 1 5] 

23x45 
pair 
[23 45] 

%"/C/Program Files/GIMP 2/bin/gimp-2.10.exe" 
file 
[#"C" 
    %"Program Files" 
    %"GIMP 2" 
    %bin 
    %gimp-2.10.exe
] 

https://github.com/red/docs/blob/master/en/typesets.adoc#series 
url 
[
    https: 
    github.com 
    red 
    docs 
    blob 
    master 
    en 
    typesets.adoc#series
] 

18-Jun-2021/14:10:52+03:00 
date 
[18-Jun-2021 2021 6 18 3:00:00 14:10:52 14 10 52.0 5 169 3:00:00 25 24] 

42 
integer 
[
    42
] 

110% 
percent 
[
    110%
]
---- 

---- 
b: [1 2 3]
probe list/into 4.5.6.7.8.9 b
---- 

---- 
[1 2 3 4 5 6 7 8 9]
---- 

anchor:super-notes[]
*Super*

_Python_ 

The `super()` function returns a temporary object of the parent class that allows access to all of its methods to its child class.

_Red_

Objects in Red are based on prototypes and not on classes – that’s why there is no need of Python’s `super()` in Red.


anchor:set-notes[]
*Sets*

_Pyton_
`set()` returns a new set object, optionally with elements taken from an iterable.

_Red_ 

Red doesn’t currently have a separate `set` datatype, but provides several functions for working with data sets with no duplicates. We can make a set from a series using `unique`:

---- 
>> colors: [Red Green Blue Yellow Red]
== [Red Green Blue Yellow Red]
>> color-set: unique colors
== [Red Green Blue Yellow]
---- 

`color-set` is still a `block!` (with the duplicates removed) and not a `set` object like in Python. We can append an existing value to it:

---- 
>> append color-set 'Red
== [Red Green Blue Yellow Red]
---- 
For comparison, Python’s `add()` method adds a given element to a set if the element is not present in the set. 

anchor:dict-notes[]
*Associative arrays*

_Python_

`dict()` creates a new dictionary initialized from an optional positional argument and a possibly empty set of keyword arguments.


_Red_

Red uses `map!` datatype to represent associative arrays of key/value pairs. Except using literal syntax `#(<key> <value>...)`, a `map!` value can be created from a block, with `to-map` conversion, resembling Python’s `dict()` used with a set of keyword arguments:

---- 
abook: [
title  "Creatures of Light and Darkness"
	author "Roger Zelazny"
	year   1969
	type   Novel
genre  "Science fiction"
]
>> type? abook
== block!
>> mbook: to-map abook
== #(
    title: "Creatures of Light and Darkness"
    author: "Roger Zelazny"
    year...
>> type? mbook
== map!
]
---- 


anchor:getattr-notes[]
*Get an attribute of an object*

_Python_

`getattr(object, name[, default])` returns the value of the named attribute of object; `name` must be a string. `getattr(x, 'foobar')` is equivalent to `x.foobar`. If the named attribute does not exist, `default` is returned if provided.

_Red_ 

Values of objects fields are referenced using path notation in Red. An alternative is to use the `get` function:

---- 
album: make object![
	title: "Caress of Steel"
	artist: "Rush"
	year: 1975
	genre: "Progressive rock"
	country: "Canada"
]
>> album/title
== "Caress of Steel"
>> get in album 'artist
== "Rush"
>> get in album to-word "year"
== 1975
---- 

If we want to recreate the Python’s `getattr()` function and specify the attribute as a string, we need to use approach from the last example: 

---- 
getattr: func[
    obj  [object!]
    attr [string!]
][
    get in obj to-word attr
]
---- 

---- 
>> getattr album "title"
== "Caress of Steel"
>> getattr album "genre"
== "Progressive rock"
---- 

anchor:hasattr-notes[]
*Check if an object has a given attribute*

_Python_ 
`hasattr(object, name)` accepts an object as its first argument and a string for its second one. Returns `True` if the strings is the name of one of the object’s  attributes, `False` if not. 

_Red_ 

Red doesn’t have such a function, but is easy to implement one. We can do it in Python’s manner, where `hassattr()` calls `getattr(object, name)` and sees whether it raises an AttributeError or not:

---- 
hasattr: function[
    obj  [object!]
    attr [string!]
][
    either error? try[get in obj to-word attr][false][true]
]
---- 

---- 
person: make object! [
   name: "Eva"
   age: 50
   country: "Sweden"
>> print hasattr person "name"
true
>> print hasattr person "color"
false
]
---- 

We can do it in another, probably more idiomatic for Red way, checking the `words-of` the object for the attribute, converted to word:

---- 
hasattr: function[
    obj  [object!]
    attr [string!]
][
    not none? find words-of obj to-word attr
]
----  

anchor:type-notes[]
*Get the type a word refers to*

_Python_

`type()` - when called with one argument, returns the type of an object. With three arguments, return a new type object.

_Red_

`type?` returns the datatype of a value. If used with the `/word` refinement, returns a `word!` value instead of a `datatype!`:

---- 
>> type? :print
== native!
>> type? type? :print
== datatype!
>> type?/word :print
== native!
>> type? type?/word :print
== word!
>> (type? type? :print) = type? type?/word :print
== false
---- 


anchor:float-notes[]
*Convert string to a floating point number*

_Python_ 

`float([x])` returns a floating point number constructed from a number or string x.

_Red_ 

`to-float` converts to `float!` value.

---- 
>> to-float "123"
== 123.0
>> to-float "123.45"
== 123.45
>> to-float "1.2345e2"
== 123.45
---- 

anchor:enumerate-notes[]
*Enumerating iterables*

_Python_

`enumerate(iterable, [start=0])` returns an enumerate object. `iterable` must be a sequence, an iterator, or some other object which supports iteration. The __next__() method of the iterator returned by `enumerate()` returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over `iterable`.

_Red_

Red doesn’t have a function similar to `enumerate()`, but let’s try to write one:

---- 
enumerate: function[
    series [series!]
    /start
        pos  [integer!]
][
    make object! [
        s: series
        i: any [pos 1]
        next: does [
            unless tail? s [
                reduce [
                    also i i: i + 1
                    take s
                ]
            ]
        ]
    ]
]
---- 

`enumerate`  takes a series as its argument and returns an object. That object’s `next` field is a function that consumes an element of the series and uses the element along with a counter to create a block, that is returned to the user. The starting index can be set using the `/start` refinement.

Here are some examples:

---- 
>> enum-colors: enumerate ["Red" "Orange" "Yellow" "Green" "Blue" "Indigo" "Violet"]
== make object! [
    s: ["Red" "Orange" "Yellow" "Green" "Blue" "Ind...
>> probe enum-colors/next
[1 "Red"]
== [1 "Red"]
>> loop 7 [probe enum-colors/next]
[2 "Orange"]
[3 "Yellow"]
[4 "Green"]
[5 "Blue"]
[6 "Indigo"]
[7 "Violet"]
none
---- 

As you see, `/next` returns `none` when the series is exhausted.

---- 
>> enum-digits: enumerate/start ["zero" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine"] 0
== make object! [
    s: ["zero" "one" "two" "three" "four" "five" "s...
>> while[not none tuple: enum-digits/next][probe tuple]
[0 "zero"]
[1 "one"]
[2 "two"]
[3 "three"]
[4 "four"]
[5 "five"]
[6 "six"]
[7 "seven"]
[8 "eight"]
[9 "nine"]
---- 
`enumerate` works with other `series!` too: 

---- 
>> enum-str: enumerate "Programming"
== make object! [
    s: "Programming"
    i: 1
    next: func [][
  ...
>> enum-str/next
== [1 #"P"]
>> enum-str/next
== [2 #"r"]
>> enum-str/next
== [3 #"o"]
---- 

---- 
>> enum-bin: enumerate/start to-binary "Hello world!" 0
== make object! [
    s: #{48656C6C6F20776F726C6421}
    i: 0
    nex...
>> enum-bin/next
== [0 72]
>> enum-bin/next
== [1 101]
>> enum-bin/next
== [2 108]
>> enum-bin/next
== [3 108]
---- 

anchor:sorted-notes[]
*Sorting*

_Python_

`sorted(iterable, *, key=None, reverse=False)`  returns a new sorted list from the items in `iterable`. `key` specifies a function of one argument that is used to extract a comparison key from each element in `iterable`

_Red_

Similarly to Python’s `sort()` method, Red’s `sort` sorts the series in place.  When we need to preserve the ordering of the original series, we can use `sort copy`:

---- 
>> colors: ["Red" "Orange" "Yellow" "Green" "Blue" "Indigo" "Violet"]
== ["Red" "Orange" "Yellow" "Green" "Blue" "Indigo" "Violet"]
>> sorted-colors: sort copy colors
== ["Blue" "Green" "Indigo" "Orange" "Red" "Violet" "Yellow"]
>> colors
== ["Red" "Orange" "Yellow" "Green" "Blue" "Indigo" "Violet"]
---- 

More details on `sort` can be found https://github.com/red/red/wiki/A-short-introduction-to-Red-for-Python-programmers#sorting-series[here]

anchor:max-notes[]
*Finding the maximum of two values*

_Python_

`max()` returns the largest item in an iterable or the largest of two or more arguments.

_Red_

Red’s `max` function accepts exactly two arguments and returns the greater of the two values. Here is an example of function that returns the maximum value in a series:

---- 
max-series: function[
    series [series!]
    /compare
        comparator [integer! any-function!]
    
][
    cmax: series/1
    cmp: any[
        get pick [comparator greater?]any-function? :comparator
        greater?
    ]
    either integer? :comparator[
        forall series[
            cmax: either cmp cmax/:comparator series/1/:comparator[
                cmax
            ][
                series/1
            ]
        ]
    ][
        forall series[
            cmax: either cmp cmax series/1[
                cmax
            ][
                series/1
            ]
        ]
    ]
]
---- 

It expects a `series!` for its argument. If no refinement is used, the function uses `greater?` to compare the values. If the `/compare` refinement is used with an `integer!` argument, the first argument must be a block of blocks and the `n-th` values in each block are compared using `greater?`. If the argument for `/compare` is a function, then the values are compared using this function. The function must have arity two and must return a `logic!` value. Here are some tests:

---- 
>> print max-series [1 3 2 5 4]
5
>> cmp-min: :lesser?
>> print max-series/compare [1 3 2 5 4] :cmp-min
1
>> colors: ["Red" "Orange" "Yellow" "Green" "Blue" "Ultraviolet" "Indigo" "Violet"]
>> cmp-len: func[a b][(length? a) >= length? b]
>> print max-series colors
Yellow
>> print max-series/compare colors :cmp-len
Ultraviolet
>> tuples: [
        ["a" 2]
        ["c" 1]
        ["b" 5]
        ["d" 4]
]
>> probe max-series/compare tuples 2
["b" 5]
---- 


