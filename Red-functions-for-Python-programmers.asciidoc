
.Most common functions in Python and their analogues in Red
[options="header"]
|====
|Python function|Red function or code|Datatypes and typesets / Notes
|len()| <<length-notes,length?>>|series! port! bitset! map! tuple! none!
|print()|<<print-notes,print>>|any-type!
|format()|<<format-notes,N/A>>|Not implemented yet
|====

anchor:length-notes[]
*length?*

_Python_

`len(s)` returns the length (the number of items) of an object. The argument may be a sequence (such as a string, bytes, tuple, list, or range) or a collection (such as a dictionary, set, or frozen set)

_Red_

`length?` returns the number of values in the `series!`, from the current index to the tail , or the number of elements needed to store the value, if it is of one of the following types: `port!` `bitset!` `map!` `tuple!` `none!`. 

(`series!` is a `typeset!` consisting of the following datatypes: `block!` `paren!` `string!` `file!` `url!` `path!` `lit-path!` `set-path!` `get-path!` `vector!` `hash!` `binary!` `tag!` `email!` `image!`)

---- 
>> length? [loop 10 [print "Hello World!"]]  ; a block! with 3 values
== 3
>> length? mold [loop 10 [print "Hello World!"]] ; `mold` returns a string!
== 32
>> file: %/C/ProgramData/Red/gui-console-2021-5-19-43168.exe  ; a file!
== %/C/ProgramData/Red/gui-console-2021-5-19-43168.exe
>> length? file
== 50
---- 

In the last example `file` has a value of `file!` datatype. File! values represent file names or directory names and paths. File! is a member of the following typesets: any-string!, series!, so it is kind of string. `length? file` returns the length of the string representing the file name and not the size of the file it may refer to. 

---- 
>> red-lang-doc: https://github.com/red/docs/blob/master/en/SUMMARY.adoc ;  url!
== https://github.com/red/docs/blob/master/en/SUMMARY.adoc
>> length? red-lang-doc
== 55
---- 

---- 
>> length? 'a/b/c/d/e/f/2 ; path!
== 7
>> length? to binary! "123456789" ; binary!
== 9
---- 

The length of an `image!` value is the number of its pixels: 
---- 
>> img: make image! [100x100 255.255.255]
== make image! [100x100 #{
    FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF...
>> length? img
== 10000   ; 100x100
----

The above examples showed the length of values that are `series!`. Let’s 

The length of the `bitset!` is computed as the smallest multiple of 8 needed to fit the highest bit number (0-origin): 

---- 
>> bits: make bitset![80 87]
== make bitset! #{0000000000000000000081}
>> length? bits
== 88
>> bits: make bitset![80 87 88]
== make bitset! #{000000000000000000008180}
>> length? bits
== 96
>> length? charset "AB"
== 72
>> length? charset "ABCDEFGH"
== 80
---- 

The length of a `map!` value is the number of its keys:

---- 
>> m: system/locale/months
== [
    "January" "February" "March" "April" "May" "June" 
    "July" "August" "Septem...
>> freq: #()
== #()
>> foreach c form m[freq/:c: 1 + any[freq/:c 0]]
== 9
>> probe freq
#(
    #"J" 3
    #"a" 5
    #"n" 2
    #"u" 6
    #"r" 9
    #"y" 4
    #" " 11
    #"F" 1
    #"e" 11
    #"b" 5
    #"M" 2
    #"c" 3
    #"h" 1
    #"A" 2
    #"p" 2
    #"i" 1
    #"l" 2
    #"g" 1
    #"s" 1
    #"t" 3
    #"S" 1
    #"m" 3
    #"O" 1
    #"o" 2
    #"N" 1
    #"v" 1
    #"D" 1
)
>> length? freq
== 27
---- 

The length of a tuple is the number of its elements:

---- 
>> img/1
== 255.255.255.0  ; rgba
>> length? img/1
== 4
---- 

If you wonder the purpose of the question mark at the end of `length?` - here’s the answer: 


[quote, Coding-Style-Guide]
Function names should strive to be single-word verbs, in order to express an action. . .   A noun or an adjective followed by a question mark is also accepted. Often, it denotes that the return value is of logic! type, but this is not a strict rule, as it is handy to form single-word action names for retrieving a property (e.g. length?, index?)

{empty} +
{empty} +

anchor:print-notes[]
*print*


_Python_ 

`print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)`
Print `objects` to the text stream `file`, separated by `sep` and followed by `end`. `sep`, `end`, `file` and `flush`, if present, must be given as keyword arguments.

_Red_

`print` outputs a value followed by a newline. If the argument is a single value, there is no need to enclose it in brackets.

---- 
>> print pi
3.141592653589793
>> numbers: [13 1 7 11 13 4 3 11 8 12]
== [13 1 7 11 13 4 3 11 8 12]
>> print numbers
13 1 7 11 13 4 3 11 8 12
>> print ["PRINT" "is" "a" "native!" "value"]
PRINT is a native! value
---- 

When the argument is a `block!`, `print` reduces it before ouput:

---- 
>> toy: "Dog"
== "Dog"
>> amount: $23
== $23.00
>> tax: 10%
== 10%
>> print["The price of" toy "is" 1 + tax * amount]
The price of Dog is $25.30
---- 

Of course all the values in a block we want to print must have values:

---- 
>> block: [a b [c d]]
== [a b [c d]]
>> print block
*** Script Error: a has no value
*** Where: print
*** Stack:
---- 

You can still print the block from the example above – you first need to `mold` it (to get its source format string representation):

---- 
>> print mold block
[a b [c d]]
---- 

In fact Red does have a built-in function that does exactly the same - `probe`:

---- 
>> probe block
[a b [c d]]
== [a b [c d]]
---- 

In addition, `probe` returns the printed value:

---- 
>> length? probe block
[a b [c d]]
== 3
---- 

When you don’t want the printed output to end with a new line, use `prin` instead of `print`: 

---- 
>> prin "Hello" print " World!"
Hello World!
---- 

Sometimes you need a new line to be inserted between the values of a single call to `print`. The newline character in Red is indicated by `#"^/"`. There are two words predefined to this value: `newline` and `lf`:

---- 
>> print ['Red "^/is a next-gen" newline 'programming lf 'language]
Red 
is a next-gen 
programming 
language
---- 


anchor:format-notes[]
*String Formatting*


_Python_

The `format()` method formats the specified value(s) and insert them inside the string's placeholder. The placeholder is defined using curly brackets: {}. The values are passed as positional and/or keyword arguments. Inside the placeholders you can add a formatting type to format the result, like alignment and number formats.

_Red_ 

Red doesn’t currently have a single function that can mimic Python’s `format()`. In most simple cases you can use `rejoin`:

---- 
>> name: "Red"
== "Red"
>> type: "full-stack"
== "full-stack"
>> rejoin [name " is a " type " programming language"]
== "Red is a full-stack programming language"
---- 

Here’s a simple function that formats a string. It takes a string as its first parameter and sets the placeholders to the corresponding named values found in the second argument – a block with “keyword” parameters:

---- 
format: function[
    {Simple string formatting. Uses a block of keyword parameters to set the values of placeholders}
    str [string!] "String to format" 
    val [block!]  "A block with set-word - value pairs"
][
    parse str[
        any[
            to remove "{" 
            change copy subs to remove "}" (select val to set-word! subs)
        ]
    ]
    str    
]
---- 

---- 
>> print format {My name is {name}. I'm {age} years old.}[age: 36 name: "John"]
My name is John. I'm 36 years old.
---- 


We can add some formatting types to the above function and make it more useful. Here’s a https://github.com/GalenIvanov/format[link] to a tiny formatting DSL.

There is much more sophisticated experimental Red dialect dedicated to formatting:  https://github.com/greggirwin/red-formatting[Red-formatting]
